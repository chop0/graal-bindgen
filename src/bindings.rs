/* automatically generated by rust-bindgen 0.58.1 */

pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 31;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __LONG_DOUBLE_USES_FLOAT128: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const __TIMESIZE: u32 = 64;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub type __u_char = crate::types::ctypes::c_uchar;
pub type __u_short = crate::types::ctypes::c_ushort;
pub type __u_int = crate::types::ctypes::c_uint;
pub type __u_long = crate::types::ctypes::c_ulong;
pub type __int8_t = crate::types::ctypes::c_schar;
pub type __uint8_t = crate::types::ctypes::c_uchar;
pub type __int16_t = crate::types::ctypes::c_short;
pub type __uint16_t = crate::types::ctypes::c_ushort;
pub type __int32_t = crate::types::ctypes::c_int;
pub type __uint32_t = crate::types::ctypes::c_uint;
pub type __int64_t = crate::types::ctypes::c_long;
pub type __uint64_t = crate::types::ctypes::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = crate::types::ctypes::c_long;
pub type __u_quad_t = crate::types::ctypes::c_ulong;
pub type __intmax_t = crate::types::ctypes::c_long;
pub type __uintmax_t = crate::types::ctypes::c_ulong;
pub type __dev_t = crate::types::ctypes::c_ulong;
pub type __uid_t = crate::types::ctypes::c_uint;
pub type __gid_t = crate::types::ctypes::c_uint;
pub type __ino_t = crate::types::ctypes::c_ulong;
pub type __ino64_t = crate::types::ctypes::c_ulong;
pub type __mode_t = crate::types::ctypes::c_uint;
pub type __nlink_t = crate::types::ctypes::c_ulong;
pub type __off_t = crate::types::ctypes::c_long;
pub type __off64_t = crate::types::ctypes::c_long;
pub type __pid_t = crate::types::ctypes::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [crate::types::ctypes::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = crate::types::ctypes::c_long;
pub type __rlim_t = crate::types::ctypes::c_ulong;
pub type __rlim64_t = crate::types::ctypes::c_ulong;
pub type __id_t = crate::types::ctypes::c_uint;
pub type __time_t = crate::types::ctypes::c_long;
pub type __useconds_t = crate::types::ctypes::c_uint;
pub type __suseconds_t = crate::types::ctypes::c_long;
pub type __daddr_t = crate::types::ctypes::c_int;
pub type __key_t = crate::types::ctypes::c_int;
pub type __clockid_t = crate::types::ctypes::c_int;
pub type __timer_t = *mut crate::types::ctypes::c_void;
pub type __blksize_t = crate::types::ctypes::c_long;
pub type __blkcnt_t = crate::types::ctypes::c_long;
pub type __blkcnt64_t = crate::types::ctypes::c_long;
pub type __fsblkcnt_t = crate::types::ctypes::c_ulong;
pub type __fsblkcnt64_t = crate::types::ctypes::c_ulong;
pub type __fsfilcnt_t = crate::types::ctypes::c_ulong;
pub type __fsfilcnt64_t = crate::types::ctypes::c_ulong;
pub type __fsword_t = crate::types::ctypes::c_long;
pub type __ssize_t = crate::types::ctypes::c_long;
pub type __syscall_slong_t = crate::types::ctypes::c_long;
pub type __syscall_ulong_t = crate::types::ctypes::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut crate::types::ctypes::c_char;
pub type __intptr_t = crate::types::ctypes::c_long;
pub type __socklen_t = crate::types::ctypes::c_uint;
pub type __sig_atomic_t = crate::types::ctypes::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = crate::types::ctypes::c_schar;
pub type int_fast16_t = crate::types::ctypes::c_long;
pub type int_fast32_t = crate::types::ctypes::c_long;
pub type int_fast64_t = crate::types::ctypes::c_long;
pub type uint_fast8_t = crate::types::ctypes::c_uchar;
pub type uint_fast16_t = crate::types::ctypes::c_ulong;
pub type uint_fast32_t = crate::types::ctypes::c_ulong;
pub type uint_fast64_t = crate::types::ctypes::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
extern "C" {
    #[doc = " Import a value from the global polyglot"]
    #[doc = " {@link org::graalvm::polyglot::Context::getPolyglotBindings bindings}."]
    #[doc = ""]
    #[doc = " @param name The name of the imported value."]
    #[doc = " @return the imported value"]
    pub fn polyglot_import(
        name: *const crate::types::ctypes::c_char,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Export a value to the global polyglot"]
    #[doc = " {@link org::graalvm::polyglot::Context::getPolyglotBindings bindings}."]
    #[doc = ""]
    #[doc = " @param name the name of the exported value"]
    #[doc = " @param value the exported value"]
    pub fn polyglot_export(
        name: *const crate::types::ctypes::c_char,
        value: *mut crate::types::ctypes::c_void,
    );
}
extern "C" {
    #[doc = " Evaluate a source of another language."]
    #[doc = ""]
    #[doc = " @param id the language identifier"]
    #[doc = " @param code the source code to be evaluated"]
    #[doc = " @return the result of the evaluation"]
    #[doc = " @see org::graalvm::polyglot::Context::eval"]
    pub fn polyglot_eval(
        id: *const crate::types::ctypes::c_char,
        code: *const crate::types::ctypes::c_char,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Evaluate a file containing source of another language."]
    #[doc = ""]
    #[doc = " The filename argument can be absolute or relative to the current working"]
    #[doc = " directory."]
    #[doc = ""]
    #[doc = " @param id the language identifier"]
    #[doc = " @param filename the file to be evaluated"]
    #[doc = " @return the result of the evaluation"]
    #[doc = " @see org::graalvm::polyglot::Context::eval"]
    pub fn polyglot_eval_file(
        id: *const crate::types::ctypes::c_char,
        filename: *const crate::types::ctypes::c_char,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Access a Java class via host interop."]
    #[doc = ""]
    #[doc = " @param classname the name of the Java class"]
    #[doc = " @return the Java class, as polyglot value"]
    pub fn polyglot_java_type(
        classname: *const crate::types::ctypes::c_char,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Access an argument of the current function."]
    #[doc = ""]
    #[doc = " This function can be used to access arguments of the current function by"]
    #[doc = " index. This function can be used to access varargs arguments without knowing"]
    #[doc = " their exact type."]
    pub fn polyglot_get_arg(i: crate::types::ctypes::c_int) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Get the number of arguments passed to the current function."]
    #[doc = ""]
    #[doc = " This function can be used to get the number of passed arguments, regular and"]
    #[doc = " varargs, without using the va_list API."]
    pub fn polyglot_get_arg_count() -> crate::types::ctypes::c_int;
}
extern "C" {
    #[doc = " Check whether a pointer points to a polyglot value."]
    #[doc = ""]
    #[doc = " @see org::graalvm::polyglot::Value"]
    pub fn polyglot_is_value(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot value is NULL."]
    #[doc = ""]
    #[doc = " Note that this is different from a native NULL pointer. A native pointer can"]
    #[doc = " point to a concrete polyglot value, but the value it points to can still"]
    #[doc = " be NULL."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot value (see"]
    #[doc = " {@link polyglot_is_value})."]
    #[doc = ""]
    #[doc = " @see org::graalvm::polyglot::Value::isNull"]
    pub fn polyglot_is_null(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot value is a number."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot value (see"]
    #[doc = " {@link polyglot_is_value})."]
    #[doc = ""]
    #[doc = " @see org::graalvm::polyglot::Value::isNumber"]
    pub fn polyglot_is_number(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot value is a boolean."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot value (see"]
    #[doc = " {@link polyglot_is_value})."]
    #[doc = ""]
    #[doc = " Note that in the Polyglot API, booleans are distinct from numbers."]
    #[doc = ""]
    #[doc = " @see org::graalvm::polyglot::Value::isBoolean"]
    pub fn polyglot_is_boolean(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot value is a string."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot value (see"]
    #[doc = " {@link polyglot_is_value})."]
    #[doc = ""]
    #[doc = " @see org::graalvm::polyglot::Value::isString"]
    pub fn polyglot_is_string(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot number can be losslessly converted to a signed"]
    #[doc = " 8-bit integer (int8_t)."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot number (see"]
    #[doc = " {@link polyglot_is_number})."]
    pub fn polyglot_fits_in_i8(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot number can be losslessly converted to a signed"]
    #[doc = " 16-bit integer (int16_t)."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot number (see"]
    #[doc = " {@link polyglot_is_number})."]
    pub fn polyglot_fits_in_i16(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot number can be losslessly converted to a signed"]
    #[doc = " 32-bit integer (int32_t)."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot number (see"]
    #[doc = " {@link polyglot_is_number})."]
    pub fn polyglot_fits_in_i32(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot number can be losslessly converted to a signed"]
    #[doc = " 64-bit integer (int64_t)."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot number (see"]
    #[doc = " {@link polyglot_is_number})."]
    pub fn polyglot_fits_in_i64(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot number can be losslessly converted to a single"]
    #[doc = " precision floating point number."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot number (see"]
    #[doc = " {@link polyglot_is_number})."]
    pub fn polyglot_fits_in_float(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot number can be losslessly converted to a double"]
    #[doc = " precision floating point number."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot number (see"]
    #[doc = " {@link polyglot_is_number})."]
    pub fn polyglot_fits_in_double(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Convert a polyglot number to a primitive int8_t value."]
    pub fn polyglot_as_i8(value: *const crate::types::ctypes::c_void) -> i8;
}
extern "C" {
    #[doc = " Convert a polyglot number to a primitive int16_t value."]
    pub fn polyglot_as_i16(value: *const crate::types::ctypes::c_void) -> i16;
}
extern "C" {
    #[doc = " Convert a polyglot number to a primitive int32_t value."]
    pub fn polyglot_as_i32(value: *const crate::types::ctypes::c_void) -> i32;
}
extern "C" {
    #[doc = " Convert a polyglot number to a primitive int64_t value."]
    pub fn polyglot_as_i64(value: *const crate::types::ctypes::c_void) -> i64;
}
extern "C" {
    #[doc = " Convert a polyglot number to a primitive float value."]
    pub fn polyglot_as_float(value: *const crate::types::ctypes::c_void) -> f32;
}
extern "C" {
    #[doc = " Convert a polyglot number to a primitive double value."]
    pub fn polyglot_as_double(value: *const crate::types::ctypes::c_void) -> f64;
}
extern "C" {
    #[doc = " Convert a polyglot boolean to a primitive bool value."]
    pub fn polyglot_as_boolean(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot value can be executed."]
    #[doc = ""]
    #[doc = " To execute a polyglot value, cast it to a function pointer type and call it."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot value (see"]
    #[doc = " {@link polyglot_is_value})."]
    pub fn polyglot_can_execute(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Invoke an object oriented method on a polyglot value."]
    #[doc = ""]
    #[doc = " @param object the object containing the method"]
    #[doc = " @param name the name of the method to be invoked"]
    #[doc = " @param ... the arguments of the method"]
    #[doc = " @return the return value of the method"]
    pub fn polyglot_invoke(
        object: *mut crate::types::ctypes::c_void,
        name: *const crate::types::ctypes::c_char,
        ...
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Check whether a polyglot value can be instantiated."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot value (see"]
    #[doc = " {@link polyglot_is_value})."]
    pub fn polyglot_can_instantiate(object: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Instantiate a polyglot value."]
    #[doc = ""]
    #[doc = " @param object the polyglot value that should be instantiated"]
    #[doc = " @param ... the arguments of the constructor"]
    #[doc = " @return the new object, as polyglot value"]
    pub fn polyglot_new_instance(
        object: *const crate::types::ctypes::c_void,
        ...
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Check whether a polyglot value is an object with named members."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot value (see"]
    #[doc = " {@link polyglot_is_value})."]
    pub fn polyglot_has_members(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot value contains a given named member."]
    #[doc = ""]
    #[doc = " @param object the polyglot value to test"]
    #[doc = " @param name the name of the member to be checked for existance"]
    #[doc = " @return true if the member exists, false otherwise"]
    pub fn polyglot_has_member(
        value: *const crate::types::ctypes::c_void,
        name: *const crate::types::ctypes::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Read a named member from a polyglot object."]
    #[doc = ""]
    #[doc = " The result is also a polyglot value. Use the {@link unbox primitive conversion"]
    #[doc = " functions} if the member contains a primitive value."]
    #[doc = ""]
    #[doc = " @param object the polyglot value to read from"]
    #[doc = " @param name the name of the member to be read"]
    #[doc = " @return a polyglot value"]
    pub fn polyglot_get_member(
        object: *const crate::types::ctypes::c_void,
        name: *const crate::types::ctypes::c_char,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Put a named member into a polyglot object."]
    #[doc = ""]
    #[doc = " This varargs function has to be called with exactly 3 arguments. The type"]
    #[doc = " of the third argument is arbitrary. The function accepts polyglot values,"]
    #[doc = " primitives or pointers."]
    #[doc = ""]
    #[doc = " @param object the polyglot object to write to"]
    #[doc = " @param name the name of the member to be put"]
    #[doc = " @param ... the written value"]
    pub fn polyglot_put_member(
        object: *mut crate::types::ctypes::c_void,
        name: *const crate::types::ctypes::c_char,
        ...
    );
}
extern "C" {
    #[doc = " Remove a named member from a polyglot object."]
    #[doc = ""]
    #[doc = " @param object the polyglot value to modify"]
    #[doc = " @param name the name of the member to be removed"]
    #[doc = " @return true if the member was successfully removed, false otherwise"]
    pub fn polyglot_remove_member(
        object: *mut crate::types::ctypes::c_void,
        name: *const crate::types::ctypes::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Check whether a polyglot value has array elements."]
    #[doc = ""]
    #[doc = " Returns false for pointers that do not point to a polyglot value (see"]
    #[doc = " {@link polyglot_is_value})."]
    pub fn polyglot_has_array_elements(value: *const crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    #[doc = " Get the size of the polyglot array."]
    pub fn polyglot_get_array_size(array: *const crate::types::ctypes::c_void) -> u64;
}
extern "C" {
    #[doc = " Read an array element from a polyglot array."]
    #[doc = ""]
    #[doc = " The result is also a polyglot value. Use the {@link unbox primitive conversion"]
    #[doc = " functions} if the member contains a primitive value."]
    #[doc = ""]
    #[doc = " @param array the polyglot array to read from"]
    #[doc = " @param idx the index of the array element"]
    #[doc = " @return a polyglot value"]
    pub fn polyglot_get_array_element(
        array: *const crate::types::ctypes::c_void,
        idx: crate::types::ctypes::c_int,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Write an array element to a polyglot array."]
    #[doc = ""]
    #[doc = " This varargs function has to be called with exactly 3 arguments. The type"]
    #[doc = " of the third argument is arbitrary. The function accepts polyglot values,"]
    #[doc = " primitives or pointers."]
    #[doc = ""]
    #[doc = " @param array the polyglot array to write to"]
    #[doc = " @param idx the index of the array element"]
    #[doc = " @param ... the written value"]
    pub fn polyglot_set_array_element(
        array: *mut crate::types::ctypes::c_void,
        idx: crate::types::ctypes::c_int,
        ...
    );
}
extern "C" {
    #[doc = " Remove an array element from a polyglot array."]
    #[doc = ""]
    #[doc = " @param array the polyglot array to modify"]
    #[doc = " @param idx the index of the removed array element"]
    #[doc = " @return true if the array element was successfully removed, false otherwise"]
    pub fn polyglot_remove_array_element(
        array: *mut crate::types::ctypes::c_void,
        idx: crate::types::ctypes::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " Get the size of a polyglot string value."]
    #[doc = ""]
    #[doc = " @return the size of the string, in unicode characters"]
    pub fn polyglot_get_string_size(value: *const crate::types::ctypes::c_void) -> u64;
}
extern "C" {
    #[doc = " Convert a polyglot value to a C string."]
    #[doc = ""]
    #[doc = " The C string will be written to a caller-provided buffer. This function"]
    #[doc = " produces a zero-terminated string."]
    #[doc = ""]
    #[doc = " At most `bufsize` bytes will be written to the buffer. *Attention:* If the"]
    #[doc = " string including the zero-terminator does not fit in the buffer, the result"]
    #[doc = " string in `buffer` may not be zero-terminated. Check the return value to"]
    #[doc = " be safe."]
    #[doc = ""]
    #[doc = " @param value the polyglot value to be converted"]
    #[doc = " @param buffer the result buffer"]
    #[doc = " @param bufsize the size of the result buffer, in bytes"]
    #[doc = " @param charset the character set for conversion"]
    #[doc = " @return the number of bytes written to the buffer, *excluding* the"]
    #[doc = "         zero-terminator"]
    pub fn polyglot_as_string(
        value: *const crate::types::ctypes::c_void,
        buffer: *mut crate::types::ctypes::c_char,
        bufsize: u64,
        charset: *const crate::types::ctypes::c_char,
    ) -> u64;
}
extern "C" {
    #[doc = " Convert a zero-terminated C string to a polyglot string."]
    #[doc = ""]
    #[doc = " The C string is expected to be terminated with a zero character. If the"]
    #[doc = " string has embedded zero characters, the conversion will stop at the first."]
    #[doc = ""]
    #[doc = " @param string a zero-terminated C string"]
    #[doc = " @param charset the character set of the C string"]
    #[doc = " @return a polyglot string"]
    pub fn polyglot_from_string(
        string: *const crate::types::ctypes::c_char,
        charset: *const crate::types::ctypes::c_char,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Convert a C string with explicit size to a polyglot string."]
    #[doc = ""]
    #[doc = " This function reads exactly `len` bytes from `string`. Zero characters are"]
    #[doc = " not handled specially, they are included in the returned string."]
    #[doc = ""]
    #[doc = " @param string a C string"]
    #[doc = " @param size the size of the C string, in bytes"]
    #[doc = " @param charset the character set of the C string"]
    #[doc = " @return a polyglot string"]
    pub fn polyglot_from_string_n(
        string: *const crate::types::ctypes::c_char,
        size: u64,
        charset: *const crate::types::ctypes::c_char,
    ) -> *mut crate::types::ctypes::c_void;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __polyglot_typeid {
    _unused: [u8; 0],
}
#[doc = " Opaque handle representing a polyglot type."]
#[doc = ""]
#[doc = " @see POLYGLOT_DECLARE_STRUCT"]
pub type polyglot_typeid = *mut __polyglot_typeid;
extern "C" {
    #[doc = " Declare an array type."]
    #[doc = ""]
    #[doc = " @param base the element type of the array"]
    #[doc = " @param len the array length"]
    #[doc = " @return a new typeid referring to an array of base with length len"]
    pub fn polyglot_array_typeid(base: polyglot_typeid, len: u64) -> polyglot_typeid;
}
extern "C" {
    #[doc = " Converts a polyglot value to a dynamic struct or array pointer."]
    #[doc = ""]
    #[doc = " The typeid passed to this function must refer to a struct or array type."]
    #[doc = " Passing a primitive typeid is not valid."]
    #[doc = ""]
    #[doc = " @see polyglot_as_MyStruct"]
    #[doc = " @see polyglot_as_MyStruct_array"]
    #[doc = ""]
    #[doc = " @param value a polyglot value"]
    #[doc = " @param typeId the type of the polyglot value"]
    #[doc = " @return struct or array view of the polyglot value"]
    pub fn polyglot_as_typed(
        value: *mut crate::types::ctypes::c_void,
        typeId: polyglot_typeid,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Create a polyglot value from a native pointer to a struct or array."]
    #[doc = ""]
    #[doc = " The typeid passed to this function must refer to a struct or array type."]
    #[doc = " Passing a primitive typeid is not valid."]
    #[doc = ""]
    #[doc = " @see polyglot_from_MyStruct"]
    #[doc = " @see polyglot_from_MyStruct_array"]
    #[doc = ""]
    #[doc = " @param ptr a pointer to a native struct or array"]
    #[doc = " @param typeid the type of ptr"]
    #[doc = " @return a polyglot value representing ptr"]
    pub fn polyglot_from_typed(
        ptr: *mut crate::types::ctypes::c_void,
        typeId: polyglot_typeid,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    #[doc = " Internal function. Do not use directly."]
    #[doc = ""]
    #[doc = " @see POLYGLOT_DECLARE_STRUCT"]
    #[doc = " @see POLYGLOT_DECLARE_TYPE"]
    pub fn __polyglot_as_typeid(ptr: *mut crate::types::ctypes::c_void) -> polyglot_typeid;
}
extern "C" {
    pub fn _graalvm_llvm_create_handle(
        managedObject: *mut crate::types::ctypes::c_void,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    pub fn _graalvm_llvm_resolve_handle(
        nativeHandle: *mut crate::types::ctypes::c_void,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    pub fn _graalvm_llvm_release_handle(nativeHandle: *mut crate::types::ctypes::c_void);
}
extern "C" {
    pub fn _graalvm_llvm_create_deref_handle(
        managedObject: *mut crate::types::ctypes::c_void,
    ) -> *mut crate::types::ctypes::c_void;
}
extern "C" {
    pub fn _graalvm_llvm_is_handle(nativeHandle: *mut crate::types::ctypes::c_void) -> bool;
}
extern "C" {
    pub fn _graalvm_llvm_points_to_handle_space(
        nativeHandle: *mut crate::types::ctypes::c_void,
    ) -> bool;
}
